// Copyright (c) 2012. All rights reserved.
// Use of this source code is governed by a BSD-style license that can
// be found in the LICENSE file.

#ifndef _LIBPROX_TEST_RTREE_REPLICATED_FROM_QUERY_HPP_
#define _LIBPROX_TEST_RTREE_REPLICATED_FROM_QUERY_HPP_

#include <cxxtest/TestSuite.h>
#include <prox/base/DefaultSimulationTraits.hpp>
#include "TestLocationServiceCache.hpp"
#include <prox/base/QueryEventListener.hpp>
#include <prox/base/AggregateListener.hpp>
#include <prox/manual/RTreeManualQueryHandler.hpp>

// Test that events generated by a manual query generate a properly replicated
// tree. We actually mark both as replicated which makes building up the
// original tree with the structure we want easier. Note that because of this
// setup with only "replicated" trees, we don't need to do any listening for
// aggregate events
class RTreeTreeReplicatedFromQueryTest : public CxxTest::TestSuite,
    public Prox::QueryEventListener<Prox::DefaultSimulationTraits, Prox::ManualQuery<Prox::DefaultSimulationTraits> >
{
public:
    typedef Prox::ManualQueryHandler<Prox::DefaultSimulationTraits> QueryHandler;
    typedef Prox::ManualQuery<Prox::DefaultSimulationTraits> Query;
    typedef Prox::QueryEvent<Prox::DefaultSimulationTraits> QueryEvent;
    typedef Prox::Reference::ObjectID ObjectID;
    typedef Prox::Reference::MotionVector3f MotionVector3f;
    typedef Prox::Reference::Vector3f Vector3f;
    typedef Prox::Reference::BoundingSphere3f BoundingSphere3f;
    typedef Prox::Reference::SolidAngle SolidAngle;
    typedef Prox::float32 float32;
    typedef Prox::uint32 uint32;
    typedef Prox::String String;
    typedef Prox::Reference::Time Time;
    typedef Prox::Reference::Duration Duration;

    TestLocationServiceCache* orig_loccache;
    QueryHandler* orig_handler;
    TestLocationServiceCache* replicated_loccache;
    QueryHandler* replicated_handler;

    // We only have one query, the one that generates the replicated tree
    Query* query;

    RTreeTreeReplicatedFromQueryTest()
     : orig_loccache(NULL),
       orig_handler(NULL),
       replicated_loccache(NULL),
       replicated_handler(NULL)
    {}

    void setUp() {
        // Note small branching factor to make tests smaller when checking split behavior
        orig_loccache = new TestLocationServiceCache();
        orig_handler = new Prox::RTreeManualQueryHandler<Prox::DefaultSimulationTraits>(3);
        orig_handler->initialize(
            orig_loccache, orig_loccache,
            true, true
        );

        replicated_loccache = new TestLocationServiceCache();
        replicated_handler = new Prox::RTreeManualQueryHandler<Prox::DefaultSimulationTraits>(3);
        replicated_handler->initialize(
            replicated_loccache, replicated_loccache,
            true, true
        );

        query = orig_handler->registerQuery(
            MotionVector3f(Time::null(), Vector3f::nil(), Vector3f::nil()),
            BoundingSphere3f(Vector3f::nil(), 0.f),
            0
        );
        query->setEventListener(this);
    }

    void tearDown() {
        assert(query != NULL);
        delete query;
        query = NULL;

        delete orig_handler; orig_handler = NULL;
        delete orig_loccache; orig_loccache = NULL;

        delete replicated_handler; replicated_handler = NULL;
        delete replicated_loccache; replicated_loccache = NULL;
    }

    void addObject(const ObjectID& id, const ObjectID& parent, bool aggregate) {
        orig_loccache->addObjectWithParent(
            id,
            parent,
            aggregate,
            MotionVector3f(Time::null(), Vector3f(0, 0, 0), Vector3f::nil()),
            Vector3f(0, 0, 0),
            0, // "object-like" point center-bounds
            1,
            "", // no mesh
            true
        );
    }
    void removeObject(const ObjectID& id) {
        orig_loccache->removeObject(id);
    }

    // Forwards object events from the orignal tree into the replicated location
    // service cache, which puts them into the query handler
    virtual void queryHasEvents(Query* query) {
        typedef std::deque<QueryEvent> QueryEventList;
        QueryEventList evts;
        query->popEvents(evts);

        while(!evts.empty()) {
            const QueryEvent& evt = evts.front();

            for(size_t aidx = 0; aidx < evt.additions().size(); aidx++) {
                QueryEvent::Addition add = evt.additions()[aidx];
                replicated_loccache->addObjectWithParent(
                    add.id(), add.parent(),
                    (add.type() == QueryEvent::Imposter),
                    orig_loccache->location(add.id()),
                    orig_loccache->centerOffset(add.id()),
                    orig_loccache->centerBoundsRadius(add.id()),
                    orig_loccache->maxSize(add.id()),
                    orig_loccache->mesh(add.id()),
                    true
                );
            }

            for(size_t ridx = 0; ridx < evt.removals().size(); ridx++) {
                QueryEvent::Removal rem = evt.removals()[ridx];
                replicated_loccache->removeObject(rem.id());
            }

            evts.pop_front();
        }
    }

    // Helper that verifies the two query handler trees have identical
    // structure. Note that we don't check that they are fully identical, just
    // that the replicated data matches the original structure.
    void verifyTreesMatch() {
        // The trees may not be replicated exactly, we really just
        // need to make sure they share the same structure and we want
        // to make sure we check it by traversing the actual data
        // structure (as opposed to, e.g., getting it from the
        // location service cache).
        typedef std::map<ObjectID, ObjectID> ParentMap;
        ParentMap orig_pm, replicated_pm;
        for(QueryHandler::NodeIterator orig_it = orig_handler->nodesBegin(), replicated_it = replicated_handler->nodesBegin();
            orig_it != orig_handler->nodesEnd() && replicated_it != replicated_handler->nodesEnd();
            orig_it++, replicated_it++)
        {
            orig_pm.insert(std::make_pair(orig_it.id(), orig_it.parentId()));
            replicated_pm.insert(std::make_pair(replicated_it.id(), replicated_it.parentId()));
        }

        // Then check that they really match
        TS_ASSERT_EQUALS(orig_pm.size(), replicated_pm.size());
        for(ParentMap::const_iterator replicated_it = replicated_pm.begin();
            replicated_it != replicated_pm.end();
            replicated_it++)
        {
            ParentMap::const_iterator orig_it = orig_pm.find(replicated_it->first);
            TS_ASSERT_DIFFERS(orig_it, orig_pm.end());
            if (orig_it == orig_pm.end()) continue;
            TS_ASSERT_EQUALS(orig_it->second, replicated_it->second);
        }
    }
// Provide this to check that trees are truly identical, rather than just that
// the replicated data matches
#define TS_ASSERT_TREES_IDENTICAL()                                     \
        TS_ASSERT_EQUALS(orig_handler->numNodes(), replicated_handler->numNodes()); \
        TS_ASSERT_EQUALS(orig_handler->numObjects(), replicated_handler->numObjects()); \
        verifyTreesMatch();
// Verify nodes have/haven't been replicated
#define TS_ASSERT_NOT_REPLICATED(ii)                            \
    TS_ASSERT(!replicated_loccache->contains(ObjID(ii)))
#define TS_ASSERT_REPLICATED(ii)                                \
    TS_ASSERT(replicated_loccache->contains(ObjID(ii)))

    static ObjectID ObjID(size_t id) {
        char raw[ObjectID::static_size];
        memset(raw, 0, ObjectID::static_size);
        ((size_t*)raw)[0] = id;
        return ObjectID(raw, ObjectID::static_size);
    }

    bool refineNode(const ObjectID& objid) {
        return query->refine(objid);
    }

    // Force refinement to the bottom of the current tree, assumes the
    // cut is at the root
    void refineToBottom() {
        for(QueryHandler::NodeIterator nit = orig_handler->nodesBegin(); nit != orig_handler->nodesEnd(); nit++) {
            // It would be nice to assert success here, but we can't
            // because when we reach replicated leaf nodes the call
            // will fail
            refineNode(nit.id());
        }
    }

    // Empty replicated trees should be the same
    void testEmptyTree() {
        TS_ASSERT_TREES_IDENTICAL();
    }

    // Test replication of a root node
    void testRoot() {
        addObject(ObjID(1), ObjID(0), true);
        TS_ASSERT_TREES_IDENTICAL();
    }

    // Test replication of a small tree, forcing refinement after all
    // nodes are inserted
    void testReplicationAfterRefinement() {
        addObject(ObjID(1), ObjID(0), true);
        addObject(ObjID(2), ObjID(1), true);
        addObject(ObjID(3), ObjID(1), true);
        addObject(ObjID(4), ObjID(2), true);
        refineToBottom();
        TS_ASSERT_TREES_IDENTICAL();
    }

    // Test that insertion of a node along the cut immediately
    // generates an event for the cut
    void testNodeInsertionAlongCut() {
        addObject(ObjID(1), ObjID(0), true);
        addObject(ObjID(2), ObjID(1), true);
        addObject(ObjID(3), ObjID(1), true);
        refineToBottom();
        TS_ASSERT_TREES_IDENTICAL();

        // Cut should be in 2, 3. Add 4 as a neighbor. This simple addition
        // (no split/merge) should always result in a simple addition to the cut
        addObject(ObjID(4), ObjID(1), true);
        TS_ASSERT_TREES_IDENTICAL();
    }

    // Test that insertion of an object in a node with the cut
    // does/does not generate events based on whether that node has
    // been refined
    void testObjectInsertionAlongCut() {
        // Just need a root node to put the cut through
        addObject(ObjID(1), ObjID(0), true);
        refineToBottom();
        TS_ASSERT_TREES_IDENTICAL();

        // Adding one object to that node should not generate an event
        // because we haven't refined that node.
        addObject(ObjID(2), ObjID(1), false);
        verifyTreesMatch();
        TS_ASSERT_NOT_REPLICATED(2);

        // Then refine and make sure we find that object
        refineToBottom();
        verifyTreesMatch();
        TS_ASSERT_REPLICATED(2);

        // Finally, with the cut refined to the children, inserting a
        // new object in that node should immediately result in
        // getting that object replicated without additional refinement
        addObject(ObjID(3), ObjID(1), false);
        verifyTreesMatch();
        TS_ASSERT_REPLICATED(3);
    }

    void testNodeRemovalAlongCut() {
        addObject(ObjID(1), ObjID(0), true);
        addObject(ObjID(2), ObjID(1), true);
        addObject(ObjID(3), ObjID(1), true);
        addObject(ObjID(4), ObjID(1), true);
        refineToBottom();
        verifyTreesMatch();

#ifdef LIBPROX_LIFT_CUTS
        removeObject(ObjID(4));
        // When lifting, this'll force lifting up to the next node, in this case
        // the root
        TS_ASSERT_EQUALS(replicated_handler->numNodes(), 1);
        // Removing the other two children should leave us in the same place
        removeObject(ObjID(3));
        TS_ASSERT_EQUALS(replicated_handler->numNodes(), 1);
        removeObject(ObjID(2));
        TS_ASSERT_EQUALS(replicated_handler->numNodes(), 1);
#else
        removeObject(ObjID(4));
        // Removing one of the nodes, node 4, should leave the cut through the
        // other two nodes, 2 and 3, intact.
        TS_ASSERT_EQUALS(replicated_handler->numNodes(), 3);
        verifyTreesMatch();
        // We should be able to do the same with node 3
        removeObject(ObjID(3));
        TS_ASSERT_EQUALS(replicated_handler->numNodes(), 2);
        verifyTreesMatch();
        // And finally drop back to only the root
        removeObject(ObjID(2));
        TS_ASSERT_EQUALS(replicated_handler->numNodes(), 1);
        verifyTreesMatch();
#endif
    }

    // Test that removal of objects in a node with the cut does/does
    // not generate events based on whether the node has been
    // refined.
    void testObjectRemovalAlongCut() {
        // Build up root + object children
        addObject(ObjID(1), ObjID(0), true);
        addObject(ObjID(2), ObjID(1), false);
        addObject(ObjID(3), ObjID(1), false);

        // We should be at the root
        verifyTreesMatch();
        TS_ASSERT_REPLICATED(1);
        TS_ASSERT_NOT_REPLICATED(2);
        TS_ASSERT_NOT_REPLICATED(3);

        // Remove object that shouldn't be in the results, which
        // should change nothing in the replicated tree
        removeObject(ObjID(2));
        verifyTreesMatch();
        TS_ASSERT_REPLICATED(1);
        TS_ASSERT_NOT_REPLICATED(3);

        // Refine everything and make sure we've gotten the object
        refineToBottom();
        verifyTreesMatch();
        TS_ASSERT_REPLICATED(3);

        // Then remove it and make sure the replicated tree has been
        // updated with this info. The two trees should now be
        // identical, having only the one root node.
        removeObject(ObjID(3));
        TS_ASSERT_TREES_IDENTICAL();

    }

    void testInsertionAboveCut() {
        // Tree with 2 levels so we can get "above" the cut, rather
        // than "next" to it as in testInsertionAlongCut
        addObject(ObjID(1), ObjID(0), true);
        addObject(ObjID(2), ObjID(1), true);
        addObject(ObjID(3), ObjID(2), true);
        refineToBottom();
        TS_ASSERT_TREES_IDENTICAL();

        // Now, inserting into the root should be above the cut (which
        // should be down at node 3 only).
        addObject(ObjID(4), ObjID(1), true);
        TS_ASSERT_TREES_IDENTICAL();
    }
};

#endif //_LIBPROX_TEST_RTREE_REPLICATED_FROM_QUERY_HPP_
